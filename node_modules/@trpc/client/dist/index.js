'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var observable = require('@trpc/server/observable');
var transformResult = require('./transformResult-e15ccdf6.js');
var links_splitLink = require('./splitLink-695ae288.js');
var links_httpBatchLink = require('./links/httpBatchLink.js');
var shared = require('@trpc/server/shared');
var httpUtils = require('./httpUtils-73a50af6.js');
var links_httpLink = require('./links/httpLink.js');
var links_loggerLink = require('./links/loggerLink.js');
var links_wsLink = require('./links/wsLink.js');

class TRPCClient {
    $request({ type , input , path , context ={}  }) {
        const chain$ = links_splitLink.createChain({
            links: this.links,
            op: {
                id: ++this.requestId,
                type,
                path,
                input,
                context
            }
        });
        return chain$.pipe(observable.share());
    }
    requestAsPromise(opts) {
        const req$ = this.$request(opts);
        const { promise , abort  } = observable.observableToPromise(req$);
        const abortablePromise = new Promise((resolve, reject)=>{
            opts.signal?.addEventListener('abort', abort);
            promise.then((envelope)=>{
                resolve(envelope.result.data);
            }).catch((err)=>{
                reject(transformResult.TRPCClientError.from(err));
            });
        });
        return abortablePromise;
    }
    query(path, input, opts) {
        return this.requestAsPromise({
            type: 'query',
            path,
            input: input,
            context: opts?.context,
            signal: opts?.signal
        });
    }
    mutation(path, input, opts) {
        return this.requestAsPromise({
            type: 'mutation',
            path,
            input: input,
            context: opts?.context,
            signal: opts?.signal
        });
    }
    subscription(path, input, opts) {
        const observable$ = this.$request({
            type: 'subscription',
            path,
            input,
            context: opts?.context
        });
        return observable$.subscribe({
            next (envelope) {
                if (envelope.result.type === 'started') {
                    opts.onStarted?.();
                } else if (envelope.result.type === 'stopped') {
                    opts.onStopped?.();
                } else {
                    opts.onData?.(envelope.result.data);
                }
            },
            error (err) {
                opts.onError?.(err);
            },
            complete () {
                opts.onComplete?.();
            }
        });
    }
    constructor(opts){
        this.requestId = 0;
        function getTransformer() {
            if (!opts.transformer) return {
                serialize: (data)=>data,
                deserialize: (data)=>data
            };
            if ('input' in opts.transformer) return {
                serialize: opts.transformer.input.serialize,
                deserialize: opts.transformer.output.deserialize
            };
            return opts.transformer;
        }
        this.runtime = {
            transformer: getTransformer()
        };
        // Initialize the links
        this.links = opts.links.map((link)=>link(this.runtime));
    }
}

function dedupeLink() {
    // initialized config
    return ()=>{
        // initialized in app
        const pending = {};
        return ({ op , next  })=>{
            // initialized for request
            if (op.type !== 'query') {
                // pass through
                return next(op);
            }
            const key = JSON.stringify([
                op.path,
                op.input
            ]);
            const obs$ = pending[key];
            if (obs$) {
                // console.log('hooking into pending', { op });
                return observable.observable((observer)=>obs$.subscribe(observer));
            }
            const shared$ = observable.observable((observer)=>{
                function reset() {
                    delete pending[key];
                }
                const subscription = next(op).subscribe({
                    next (v) {
                        observer.next(v);
                    },
                    error (e) {
                        reset();
                        observer.error(e);
                    },
                    complete () {
                        reset();
                        observer.complete();
                    }
                });
                return ()=>{
                    reset();
                    subscription.unsubscribe();
                };
            }).pipe(observable.share());
            pending[key] = shared$;
            return shared$;
        };
    };
}

function retryLink(opts) {
    // initialized config
    return ()=>{
        // initialized in app
        return ({ op , next  })=>{
            // initialized for request
            return observable.observable((observer)=>{
                let next$ = null;
                let attempts = 0;
                let isDone = false;
                function attempt() {
                    attempts++;
                    next$?.unsubscribe();
                    next$ = next(op).subscribe({
                        error (error) {
                            if (attempts >= opts.attempts) {
                                observer.error(error);
                                return;
                            }
                            attempt();
                        },
                        next (result) {
                            if ('result' in result.result) {
                                isDone = true;
                                observer.next(result);
                                return;
                            }
                            if (attempts >= opts.attempts) {
                                isDone = true;
                                observer.next(result);
                                return;
                            }
                            attempt();
                        },
                        complete () {
                            if (isDone) {
                                observer.complete();
                            }
                        }
                    });
                }
                attempt();
                return ()=>{
                    isDone = true;
                    next$?.unsubscribe();
                };
            });
        };
    };
}

/**
 * @deprecated use `createTRPCProxyClient` instead
 */ function createTRPCClient(opts) {
    const getLinks = ()=>{
        if ('links' in opts) {
            return opts.links;
        }
        return [
            links_httpBatchLink.httpBatchLink(opts)
        ];
    };
    const client = new TRPCClient({
        transformer: opts.transformer,
        links: getLinks()
    });
    return client;
}

const clientCallTypeMap = {
    query: 'query',
    mutate: 'mutation',
    subscribe: 'subscription'
};
/**
 * @deprecated use `createTRPCProxyClient` instead
 * @internal
 */ function createTRPCClientProxy(client) {
    const proxy = shared.createProxy(({ path , args  })=>{
        const pathCopy = [
            ...path
        ];
        const clientCallType = pathCopy.pop();
        const procedureType = clientCallTypeMap[clientCallType];
        const fullPath = pathCopy.join('.');
        return client[procedureType](fullPath, ...args);
    });
    return proxy;
}
function createTRPCProxyClient(opts) {
    const client = new TRPCClient(opts);
    const proxy = createTRPCClientProxy(client);
    return proxy;
}

exports.TRPCClientError = transformResult.TRPCClientError;
exports.splitLink = links_splitLink.splitLink;
exports.httpBatchLink = links_httpBatchLink.httpBatchLink;
exports.getFetch = httpUtils.getFetch;
exports.httpLink = links_httpLink.httpLink;
exports.loggerLink = links_loggerLink.loggerLink;
exports.createWSClient = links_wsLink.createWSClient;
exports.wsLink = links_wsLink.wsLink;
exports.createTRPCClient = createTRPCClient;
exports.createTRPCClientProxy = createTRPCClientProxy;
exports.createTRPCProxyClient = createTRPCProxyClient;
exports.dedupeLink = dedupeLink;
exports.retryLink = retryLink;
