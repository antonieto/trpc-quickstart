import { createProxy } from '@trpc/server/shared';
import { useQuery, useMutation, hashQueryKey, useInfiniteQuery } from '@tanstack/react-query';
import { createTRPCClient } from '@trpc/client';
import React, { createContext, useState, useEffect, useCallback, useMemo } from 'react';

/**
 * We treat `undefined` as an input the same as omitting an `input`
 * https://github.com/trpc/trpc/issues/2290
 */ function getQueryKey(path, input) {
    return input === undefined ? [
        path
    ] : [
        path,
        input
    ];
}

/**
 * Create proxy for decorating procedures
 * @internal
 */ function createReactProxyDecoration(name, hooks) {
    return createProxy((opts)=>{
        const args = opts.args;
        const pathCopy = [
            name,
            ...opts.path
        ];
        // The last arg is for instance `.useMutation` or `.useQuery()`
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const lastArg = pathCopy.pop();
        // The `path` ends up being something like `post.byId`
        const path = pathCopy.join('.');
        if (lastArg === 'useMutation') {
            return hooks[lastArg](path, ...args);
        }
        const [input, ...rest] = args;
        const queryKey = getQueryKey(path, input);
        return hooks[lastArg](queryKey, ...rest);
    });
}

const contextProps = [
    'queryClient',
    'client',
    'ssrContext',
    'ssrState',
    'abortOnUnmount', 
];
const TRPCContext = /*#__PURE__*/ createContext(null);

/**
 * @internal
 */ function createReactQueryUtilsProxy(context) {
    const proxy = new Proxy(()=>{
    // noop
    }, {
        get (_obj, name) {
            if (typeof name !== 'string') {
                throw new Error('Not supported');
            }
            const contextName = name;
            if (contextProps.includes(contextName)) {
                return context[contextName];
            }
            return createProxy(({ path , args  })=>{
                const pathCopy = [
                    name,
                    ...path
                ];
                const utilName = pathCopy.pop();
                const fullPath = pathCopy.join('.');
                const getOpts = (name)=>{
                    if ([
                        'setData',
                        'setInfiniteData'
                    ].includes(name)) {
                        const [updater, input, ...rest] = args;
                        const queryKey = getQueryKey(fullPath, input);
                        return {
                            input,
                            queryKey,
                            updater,
                            rest
                        };
                    }
                    const [input1, ...rest1] = args;
                    const queryKey1 = getQueryKey(fullPath, input1);
                    return {
                        input: input1,
                        queryKey: queryKey1,
                        rest: rest1
                    };
                };
                const { queryKey , rest , updater , input  } = getOpts(utilName);
                const contextMap = {
                    fetch: ()=>context.fetchQuery(queryKey, ...rest),
                    fetchInfinite: ()=>context.fetchInfiniteQuery(queryKey, ...rest),
                    prefetch: ()=>context.prefetchQuery(queryKey, ...rest),
                    prefetchInfinite: ()=>context.prefetchInfiniteQuery(queryKey, ...rest),
                    invalidate: ()=>context.invalidateQueries(queryKey, ...rest),
                    refetch: ()=>context.refetchQueries(queryKey, ...rest),
                    cancel: ()=>context.cancelQuery(queryKey, ...rest),
                    setData: ()=>context.setQueryData(queryKey, updater, ...rest),
                    setInfiniteData: ()=>context.setInfiniteQueryData(queryKey, input, ...rest),
                    getData: ()=>context.getQueryData(queryKey),
                    getInfiniteData: ()=>context.getInfiniteQueryData(queryKey)
                };
                return contextMap[utilName]();
            });
        }
    });
    return proxy;
}

function getClientArgs(pathAndInput, opts) {
    const [path, input] = pathAndInput;
    return [
        path,
        input,
        opts?.trpc
    ];
}
/**
 * Create strongly typed react hooks
 * @internal
 */ function createHooksInternal() {
    const Context = TRPCContext;
    const createClient = (opts)=>{
        return createTRPCClient(opts);
    };
    const TRPCProvider = (props)=>{
        const { abortOnUnmount =false , client , queryClient , ssrContext  } = props;
        const [ssrState, setSSRState] = useState(props.ssrState ?? false);
        useEffect(()=>{
            // Only updating state to `mounted` if we are using SSR.
            // This makes it so we don't have an unnecessary re-render when opting out of SSR.
            setSSRState((state)=>state ? 'mounted' : false);
        }, []);
        return /*#__PURE__*/ React.createElement(Context.Provider, {
            value: {
                abortOnUnmount,
                queryClient,
                client,
                ssrContext: ssrContext || null,
                ssrState,
                fetchQuery: useCallback((pathAndInput, opts)=>{
                    return queryClient.fetchQuery(pathAndInput, ()=>client.query(...getClientArgs(pathAndInput, opts)), opts);
                }, [
                    client,
                    queryClient
                ]),
                fetchInfiniteQuery: useCallback((pathAndInput, opts)=>{
                    return queryClient.fetchInfiniteQuery(pathAndInput, ({ pageParam  })=>{
                        const [path, input] = pathAndInput;
                        const actualInput = {
                            ...input,
                            cursor: pageParam
                        };
                        return client.query(...getClientArgs([
                            path,
                            actualInput
                        ], opts));
                    }, opts);
                }, [
                    client,
                    queryClient
                ]),
                prefetchQuery: useCallback((pathAndInput, opts)=>{
                    return queryClient.prefetchQuery(pathAndInput, ()=>client.query(...getClientArgs(pathAndInput, opts)), opts);
                }, [
                    client,
                    queryClient
                ]),
                prefetchInfiniteQuery: useCallback((pathAndInput, opts)=>{
                    return queryClient.prefetchInfiniteQuery(pathAndInput, ({ pageParam  })=>{
                        const [path, input] = pathAndInput;
                        const actualInput = {
                            ...input,
                            cursor: pageParam
                        };
                        return client.query(...getClientArgs([
                            path,
                            actualInput
                        ], opts));
                    }, opts);
                }, [
                    client,
                    queryClient
                ]),
                invalidateQueries: useCallback((...args)=>queryClient.invalidateQueries(...args), [
                    queryClient
                ]),
                refetchQueries: useCallback((...args)=>queryClient.refetchQueries(...args), [
                    queryClient
                ]),
                cancelQuery: useCallback((pathAndInput)=>{
                    return queryClient.cancelQueries(pathAndInput);
                }, [
                    queryClient
                ]),
                setQueryData: useCallback((...args)=>queryClient.setQueryData(...args), [
                    queryClient
                ]),
                getQueryData: useCallback((...args)=>queryClient.getQueryData(...args), [
                    queryClient
                ]),
                setInfiniteQueryData: useCallback((...args)=>{
                    return queryClient.setQueryData(...args);
                }, [
                    queryClient
                ]),
                getInfiniteQueryData: useCallback((...args)=>queryClient.getQueryData(...args), [
                    queryClient
                ])
            }
        }, props.children);
    };
    function useContext() {
        return React.useContext(Context);
    }
    /**
   * Hack to make sure errors return `status`='error` when doing SSR
   * @link https://github.com/trpc/trpc/pull/1645
   */ function useSSRQueryOptionsIfNeeded(pathAndInput, opts) {
        const { queryClient , ssrState  } = useContext();
        return ssrState && ssrState !== 'mounted' && queryClient.getQueryCache().find(pathAndInput)?.state.status === 'error' ? {
            retryOnMount: false,
            ...opts
        } : opts;
    }
    function useQuery$1(pathAndInput, opts) {
        const { abortOnUnmount , client , ssrState , queryClient , prefetchQuery  } = useContext();
        if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && opts?.enabled !== false && !queryClient.getQueryCache().find(pathAndInput)) {
            void prefetchQuery(pathAndInput, opts);
        }
        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, opts);
        // request option should take priority over global
        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;
        return useQuery(pathAndInput, (queryFunctionContext)=>{
            const actualOpts = {
                ...ssrOpts,
                trpc: {
                    ...ssrOpts?.trpc,
                    ...shouldAbortOnUnmount ? {
                        signal: queryFunctionContext.signal
                    } : {}
                }
            };
            return client.query(...getClientArgs(pathAndInput, actualOpts));
        }, ssrOpts);
    }
    function useMutation$1(path, opts) {
        const { client  } = useContext();
        return useMutation((input)=>{
            const actualPath = Array.isArray(path) ? path[0] : path;
            return client.mutation(...getClientArgs([
                actualPath,
                input
            ], opts));
        }, opts);
    }
    /* istanbul ignore next */ /**
   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️
   *  **Experimental.** API might change without major version bump
   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠
   */ function useSubscription(pathAndInput, opts) {
        const enabled = opts?.enabled ?? true;
        const queryKey = hashQueryKey(pathAndInput);
        const { client  } = useContext();
        return useEffect(()=>{
            if (!enabled) {
                return;
            }
            const [path, input] = pathAndInput;
            let isStopped = false;
            const subscription = client.subscription(path, input ?? undefined, {
                onStarted: ()=>{
                    if (!isStopped) {
                        opts.onStarted?.();
                    }
                },
                onData: (data)=>{
                    if (!isStopped) {
                        opts.onData(data);
                    }
                },
                onError: (err)=>{
                    if (!isStopped) {
                        opts.onError?.(err);
                    }
                }
            });
            return ()=>{
                isStopped = true;
                subscription.unsubscribe();
            };
        // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [
            queryKey,
            enabled
        ]);
    }
    function useInfiniteQuery$1(pathAndInput, opts) {
        const [path, input] = pathAndInput;
        const { client , ssrState , prefetchInfiniteQuery , queryClient , abortOnUnmount ,  } = useContext();
        if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && opts?.enabled !== false && !queryClient.getQueryCache().find(pathAndInput)) {
            void prefetchInfiniteQuery(pathAndInput, opts);
        }
        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, opts);
        // request option should take priority over global
        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;
        return useInfiniteQuery(pathAndInput, (queryFunctionContext)=>{
            const actualOpts = {
                ...ssrOpts,
                trpc: {
                    ...ssrOpts?.trpc,
                    ...shouldAbortOnUnmount ? {
                        signal: queryFunctionContext.signal
                    } : {}
                }
            };
            const actualInput = {
                ...input ?? {},
                cursor: queryFunctionContext.pageParam
            };
            return client.query(...getClientArgs([
                path,
                actualInput
            ], actualOpts));
        }, ssrOpts);
    }
    const useDehydratedState = (client, trpcState)=>{
        const transformed = useMemo(()=>{
            if (!trpcState) {
                return trpcState;
            }
            return client.runtime.transformer.deserialize(trpcState);
        }, [
            trpcState,
            client
        ]);
        return transformed;
    };
    return {
        Provider: TRPCProvider,
        createClient,
        useContext,
        useQuery: useQuery$1,
        useMutation: useMutation$1,
        useSubscription,
        useDehydratedState,
        useInfiniteQuery: useInfiniteQuery$1
    };
}

export { createReactProxyDecoration as a, createHooksInternal as b, createReactQueryUtilsProxy as c };
