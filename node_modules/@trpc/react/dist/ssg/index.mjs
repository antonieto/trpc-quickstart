import { QueryClient, dehydrate } from '@tanstack/react-query';
import { assertNotBrowser, callProcedure } from '@trpc/server';
import { createProxy } from '@trpc/server/shared';

assertNotBrowser();
/**
 * Create functions you can use for server-side rendering / static generation
 * @deprecated use `createProxySSGHelpers` instead
 */ function createSSGHelpers({ router , transformer , ctx , queryClientConfig  }) {
    const queryClient = new QueryClient(queryClientConfig);
    const serialize = transformer ? ('input' in transformer ? transformer.input : transformer).serialize : (obj)=>obj;
    const prefetchQuery = async (...pathAndInput)=>{
        return queryClient.prefetchQuery(pathAndInput, ()=>{
            return callProcedure({
                procedures: router._def.procedures,
                path: pathAndInput[0],
                rawInput: pathAndInput[1],
                ctx,
                type: 'query'
            });
        });
    };
    const prefetchInfiniteQuery = async (...pathAndInput)=>{
        return queryClient.prefetchInfiniteQuery(pathAndInput, ()=>{
            return callProcedure({
                procedures: router._def.procedures,
                path: pathAndInput[0],
                rawInput: pathAndInput[1],
                ctx,
                type: 'query'
            });
        });
    };
    const fetchQuery = async (...pathAndInput)=>{
        return queryClient.fetchQuery(pathAndInput, ()=>{
            return callProcedure({
                procedures: router._def.procedures,
                path: pathAndInput[0],
                rawInput: pathAndInput[1],
                ctx,
                type: 'query'
            });
        });
    };
    const fetchInfiniteQuery = async (...pathAndInput)=>{
        return queryClient.fetchInfiniteQuery(pathAndInput, ()=>{
            return callProcedure({
                procedures: router._def.procedures,
                path: pathAndInput[0],
                rawInput: pathAndInput[1],
                ctx,
                type: 'query'
            });
        });
    };
    function _dehydrate(opts = {
        shouldDehydrateQuery () {
            // makes sure to serialize errors
            return true;
        }
    }) {
        const before = dehydrate(queryClient, opts);
        const after = serialize(before);
        return after;
    }
    return {
        prefetchQuery,
        prefetchInfiniteQuery,
        fetchQuery,
        fetchInfiniteQuery,
        dehydrate: _dehydrate,
        queryClient
    };
}

/**
 * Create functions you can use for server-side rendering / static generation
 */ function createProxySSGHelpers(opts) {
    const helpers = createSSGHelpers(opts);
    const proxy = new Proxy(()=>{
    // noop
    }, {
        get (_obj, name) {
            if (name === 'queryClient') {
                return helpers.queryClient;
            }
            if (name === 'dehydrate') {
                return helpers.dehydrate;
            }
            if (typeof name === 'string') {
                return createProxy((opts)=>{
                    const args = opts.args;
                    const pathCopy = [
                        name,
                        ...opts.path
                    ];
                    const utilName = pathCopy.pop();
                    const fullPath = pathCopy.join('.');
                    switch(utilName){
                        case 'fetch':
                            {
                                return helpers.fetchQuery(fullPath, ...args);
                            }
                        case 'fetchInfinite':
                            {
                                return helpers.fetchInfiniteQuery(fullPath, ...args);
                            }
                        case 'prefetch':
                            {
                                return helpers.prefetchQuery(fullPath, ...args);
                            }
                        case 'prefetchInfinite':
                            {
                                return helpers.prefetchInfiniteQuery(fullPath, ...args);
                            }
                    }
                });
            }
            throw new Error('Not supported');
        }
    });
    return proxy;
}

export { createProxySSGHelpers, createSSGHelpers };
