import { FlatOverwrite, MaybePromise } from '../../types';
import { MiddlewareFunction } from '../middleware';
import { Parser, inferParser } from '../parser';
import { MutationProcedure, ProcedureParams, QueryProcedure, SubscriptionProcedure } from '../procedure';
import { ProcedureType } from '../types';
import { RootConfig } from './config';
import { ResolveOptions } from './utils';
import { DefaultValue as FallbackValue, Overwrite, OverwriteKnown, UnsetMarker } from './utils';
declare type CreateProcedureReturnInput<TPrev extends ProcedureParams, TNext extends ProcedureParams> = ProcedureBuilder<{
    _config: TPrev['_config'];
    _meta: TPrev['_meta'];
    _ctx_in: TPrev['_ctx_in'];
    _ctx_out: Overwrite<TPrev['_ctx_out'], TNext['_ctx_out']>;
    _input_in: FallbackValue<TNext['_input_in'], TPrev['_input_in']>;
    _input_out: FallbackValue<TNext['_input_out'], TPrev['_input_out']>;
    _output_in: FallbackValue<TNext['_output_in'], TPrev['_output_in']>;
    _output_out: FallbackValue<TNext['_output_out'], TPrev['_output_out']>;
}>;
declare type OverwriteIfDefined<TType, TWith> = UnsetMarker extends TType ? TWith : FlatOverwrite<TType, TWith>;
declare type ErrorMessage<TMessage extends string> = TMessage;
export interface ProcedureBuilder<TParams extends ProcedureParams> {
    /**
     * Add an input parser to the procedure.
     */
    input<TParser extends Parser>(schema: TParams['_input_out'] extends UnsetMarker ? TParser : inferParser<TParser>['out'] extends Record<string, unknown> ? TParams['_input_out'] extends Record<string, unknown> ? TParser : ErrorMessage<'All input parsers did not resolve to an object'> : ErrorMessage<'All input parsers did not resolve to an object'>): ProcedureBuilder<{
        _config: TParams['_config'];
        _meta: TParams['_meta'];
        _ctx_in: TParams['_ctx_in'];
        _ctx_out: TParams['_ctx_out'];
        _input_in: OverwriteIfDefined<TParams['_input_in'], inferParser<TParser>['in']>;
        _input_out: OverwriteIfDefined<TParams['_input_out'], inferParser<TParser>['out']>;
        _output_in: TParams['_output_in'];
        _output_out: TParams['_output_out'];
    }>;
    /**
     * Add an output parser to the procedure.
     */
    output<TParser extends Parser>(schema: TParser): ProcedureBuilder<{
        _config: TParams['_config'];
        _meta: TParams['_meta'];
        _ctx_in: TParams['_ctx_in'];
        _ctx_out: TParams['_ctx_out'];
        _input_in: TParams['_input_in'];
        _input_out: TParams['_input_out'];
        _output_in: inferParser<TParser>['in'];
        _output_out: inferParser<TParser>['out'];
    }>;
    /**
     * Add a meta data to the procedure.
     */
    meta(meta: TParams['_meta']): ProcedureBuilder<TParams>;
    /**
     * Add a middleware to the procedure.
     */
    use<TNewParams extends ProcedureParams>(fn: MiddlewareFunction<TParams, TNewParams>): CreateProcedureReturnInput<TParams, TNewParams>;
    /**
     * Extend the procedure with another procedure.
     * @warning The TypeScript inference fails when chaining concatenated procedures.
     */
    unstable_concat<TProcedureReturnType extends AnyProcedureBuilder>(proc: TProcedureReturnType): TProcedureReturnType extends ProcedureBuilder<infer $TParams> ? CreateProcedureReturnInput<TParams, $TParams> : never;
    /**
     * Query procedure
     */
    query<TOutput>(resolver: (opts: ResolveOptions<TParams>) => MaybePromise<FallbackValue<TParams['_output_in'], TOutput>>): UnsetMarker extends TParams['_output_out'] ? QueryProcedure<OverwriteKnown<TParams, {
        _output_in: TOutput;
        _output_out: TOutput;
    }>> : QueryProcedure<TParams>;
    /**
     * Mutation procedure
     */
    mutation<TOutput>(resolver: (opts: ResolveOptions<TParams>) => MaybePromise<FallbackValue<TParams['_output_in'], TOutput>>): UnsetMarker extends TParams['_output_out'] ? MutationProcedure<OverwriteKnown<TParams, {
        _output_in: TOutput;
        _output_out: TOutput;
    }>> : MutationProcedure<TParams>;
    /**
     * Mutation procedure
     */
    subscription<TOutput>(resolver: (opts: ResolveOptions<TParams>) => MaybePromise<FallbackValue<TParams['_output_in'], TOutput>>): UnsetMarker extends TParams['_output_out'] ? SubscriptionProcedure<OverwriteKnown<TParams, {
        _output_in: TOutput;
        _output_out: TOutput;
    }>> : SubscriptionProcedure<TParams>;
    /**
     * @internal
     */
    _def: {
        inputs: Parser[];
        output?: Parser;
        meta?: TParams['_meta'];
        resolver?: ProcedureBuilderResolver;
        middlewares: ProcedureBuilderMiddleware[];
        mutation?: boolean;
        query?: boolean;
        subscription?: boolean;
    };
}
declare type AnyProcedureBuilder = ProcedureBuilder<any>;
export declare type AnyProcedureBuilderDef = AnyProcedureBuilder['_def'];
export declare type ProcedureBuilderMiddleware = MiddlewareFunction<any, any>;
export declare type ProcedureBuilderResolver = (opts: ResolveOptions<any>) => Promise<unknown>;
export declare function createBuilder<TConfig extends RootConfig>(initDef?: AnyProcedureBuilderDef): ProcedureBuilder<{
    _config: TConfig;
    _ctx_in: TConfig['ctx'];
    _ctx_out: TConfig['ctx'];
    _input_in: UnsetMarker;
    _input_out: UnsetMarker;
    _output_in: UnsetMarker;
    _output_out: UnsetMarker;
    _meta: TConfig['meta'];
}>;
/**
 * @internal
 */
export interface ProcedureCallOptions {
    ctx: unknown;
    rawInput: unknown;
    input?: unknown;
    path: string;
    type: ProcedureType;
}
export {};
//# sourceMappingURL=procedureBuilder.d.ts.map