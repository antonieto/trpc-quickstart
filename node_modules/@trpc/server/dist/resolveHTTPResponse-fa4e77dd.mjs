import { T as TRPCError, g as getCauseFromUnknown, a as getTRPCErrorFromUnknown } from './TRPCError-e99e7cbe.mjs';
import { i as invert, T as TRPC_ERROR_CODES_BY_KEY } from './codes-f164ac85.mjs';
import { c as createProxy } from './index-47817162.mjs';
import { t as transformTRPCResponse } from './transformTRPCResponse-c8138d5f.mjs';

/* istanbul ignore file */ function assertNotBrowser() {
    if (typeof window !== 'undefined' && !('Deno' in window) && process.env.NODE_ENV !== 'test' && process.env.JEST_WORKER_ID === undefined) {
        throw new Error('Imported server-only code in the browser');
    }
}

const defaultFormatter = ({ shape  })=>{
    return shape;
};

const TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);
const JSONRPC2_TO_HTTP_CODE = {
    PARSE_ERROR: 400,
    BAD_REQUEST: 400,
    NOT_FOUND: 404,
    INTERNAL_SERVER_ERROR: 500,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    TIMEOUT: 408,
    CONFLICT: 409,
    CLIENT_CLOSED_REQUEST: 499,
    PRECONDITION_FAILED: 412,
    PAYLOAD_TOO_LARGE: 413,
    METHOD_NOT_SUPPORTED: 405
};
function getStatusCodeFromKey(code) {
    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;
}
function getHTTPStatusCode(json) {
    const arr = Array.isArray(json) ? json : [
        json
    ];
    const httpStatuses = new Set(arr.map((res)=>{
        if ('error' in res) {
            const data = res.error.data;
            if (typeof data.httpStatus === 'number') {
                return data.httpStatus;
            }
            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];
            return getStatusCodeFromKey(code);
        }
        return 200;
    }));
    if (httpStatuses.size !== 1) {
        return 207;
    }
    const httpStatus = httpStatuses.values().next().value;
    return httpStatus;
}
function getHTTPStatusCodeFromError(error) {
    const { code  } = error;
    return getStatusCodeFromKey(code);
}

/* eslint-disable @typescript-eslint/no-explicit-any */ /**
 * @public
 */ /**
 * @internal
 */ function getDataTransformer(transformer) {
    if ('input' in transformer) {
        return transformer;
    }
    return {
        input: transformer,
        output: transformer
    };
}
/**
 * @internal
 */ const defaultTransformer = {
    _default: true,
    input: {
        serialize: (obj)=>obj,
        deserialize: (obj)=>obj
    },
    output: {
        serialize: (obj)=>obj,
        deserialize: (obj)=>obj
    }
};

/**
 * Ensures there are no duplicate keys when building a procedure.
 */ function mergeWithoutOverrides(obj1, ...objs) {
    const newObj = Object.assign(Object.create(null), obj1);
    for (const overrides of objs){
        for(const key in overrides){
            if (key in newObj && newObj[key] !== overrides[key]) {
                throw new Error(`Duplicate key ${key}`);
            }
            newObj[key] = overrides[key];
        }
    }
    return newObj;
}

/**
 * Create an object without inheriting anything from `Object.prototype`
 * @internal
 */ function omitPrototype(obj) {
    return Object.assign(Object.create(null), obj);
}

const procedureTypes = [
    'query',
    'mutation',
    'subscription'
];

function isRouter(procedureOrRouter) {
    return 'router' in procedureOrRouter._def;
}
const emptyRouter = {
    _ctx: null,
    _errorShape: null,
    _meta: null,
    queries: {},
    mutations: {},
    subscriptions: {},
    errorFormatter: defaultFormatter,
    transformer: defaultTransformer
};
/**
 *
 * @internal
 */ function createRouterFactory(defaults) {
    return function createRouterInner(opts) {
        const routerProcedures = omitPrototype({});
        function recursiveGetPaths(procedures, path = '') {
            for (const [key, procedureOrRouter] of Object.entries(procedures ?? {})){
                const newPath = `${path}${key}`;
                if (isRouter(procedureOrRouter)) {
                    recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);
                    continue;
                }
                routerProcedures[newPath] = procedureOrRouter;
            }
        }
        recursiveGetPaths(opts);
        const result = mergeWithoutOverrides({
            transformer: defaults?.transformer ?? defaultTransformer,
            errorFormatter: defaults?.errorFormatter ?? defaultFormatter
        }, {
            procedures: routerProcedures
        });
        const _def = {
            router: true,
            procedures: {},
            ...emptyRouter,
            ...result,
            record: opts,
            queries: Object.entries(result.procedures || {}).filter((pair)=>pair[1]._def.query).reduce((acc, [key, val])=>({
                    ...acc,
                    [key]: val
                }), {}),
            mutations: Object.entries(result.procedures || {}).filter((pair)=>pair[1]._def.mutation).reduce((acc, [key, val])=>({
                    ...acc,
                    [key]: val
                }), {}),
            subscriptions: Object.entries(result.procedures || {}).filter((pair)=>pair[1]._def.subscription).reduce((acc, [key, val])=>({
                    ...acc,
                    [key]: val
                }), {})
        };
        const router = {
            ...opts,
            _def,
            transformer: _def.transformer,
            errorFormatter: _def.errorFormatter,
            createCaller (ctx) {
                const proxy = createProxy(({ path , args  })=>{
                    // interop mode
                    if (path.length === 1 && procedureTypes.includes(path[0])) {
                        return callProcedure({
                            procedures: _def.procedures,
                            path: args[0],
                            rawInput: args[1],
                            ctx,
                            type: path[0]
                        });
                    }
                    const fullPath = path.join('.');
                    const procedure = _def.procedures[fullPath];
                    let type = 'query';
                    if (procedure._def.mutation) {
                        type = 'mutation';
                    } else if (procedure._def.subscription) {
                        type = 'subscription';
                    }
                    return procedure({
                        path: fullPath,
                        rawInput: args[0],
                        ctx,
                        type
                    });
                });
                return proxy;
            },
            getErrorShape (opts) {
                const { path , error  } = opts;
                const { code  } = opts.error;
                const shape = {
                    message: error.message,
                    code: TRPC_ERROR_CODES_BY_KEY[code],
                    data: {
                        code,
                        httpStatus: getHTTPStatusCodeFromError(error)
                    }
                };
                if (process.env.NODE_ENV !== 'production' && typeof opts.error.stack === 'string') {
                    shape.data.stack = opts.error.stack;
                }
                if (typeof path === 'string') {
                    shape.data.path = path;
                }
                return this._def.errorFormatter({
                    ...opts,
                    shape
                });
            }
        };
        return router;
    };
}
/**
 * @internal
 */ function callProcedure(opts) {
    const { type , path  } = opts;
    if (!(path in opts.procedures) || !opts.procedures[path]?._def[type]) {
        throw new TRPCError({
            code: 'NOT_FOUND',
            message: `No "${type}"-procedure on path "${path}"`
        });
    }
    const procedure = opts.procedures[path];
    return procedure(opts);
}

/**
 * @internal
 */ // FIXME this should use RootConfig
function createMiddlewareFactory() {
    return function createMiddleware(fn) {
        return fn;
    };
}
function isPlainObject(obj) {
    return obj && typeof obj === 'object' && !Array.isArray(obj);
}
/**
 * @internal
 * Please note, `trpc-openapi` uses this function.
 */ function createInputMiddleware(parse) {
    const inputMiddleware = async ({ next , rawInput , input ,  })=>{
        let parsedInput;
        try {
            parsedInput = await parse(rawInput);
        } catch (cause) {
            throw new TRPCError({
                code: 'BAD_REQUEST',
                cause: getCauseFromUnknown(cause)
            });
        }
        // Multiple input parsers
        const combinedInput = isPlainObject(input) && isPlainObject(parsedInput) ? {
            ...input,
            ...parsedInput
        } : parsedInput;
        // TODO fix this typing?
        return next({
            input: combinedInput
        });
    };
    inputMiddleware._type = 'input';
    return inputMiddleware;
}
/**
 * @internal
 */ function createOutputMiddleware(parse) {
    const outputMiddleware = async ({ next  })=>{
        const result = await next();
        if (!result.ok) {
            // pass through failures without validating
            return result;
        }
        try {
            const data = await parse(result.data);
            return {
                ...result,
                data
            };
        } catch (cause) {
            throw new TRPCError({
                message: 'Output validation failed',
                code: 'INTERNAL_SERVER_ERROR',
                cause: getCauseFromUnknown(cause)
            });
        }
    };
    outputMiddleware._type = 'output';
    return outputMiddleware;
}

function getParseFn(procedureParser) {
    const parser = procedureParser;
    if (typeof parser === 'function') {
        // ProcedureParserCustomValidatorEsque
        return parser;
    }
    if (typeof parser.parseAsync === 'function') {
        // ProcedureParserZodEsque
        return parser.parseAsync.bind(parser);
    }
    if (typeof parser.parse === 'function') {
        // ProcedureParserZodEsque
        return parser.parse.bind(parser);
    }
    if (typeof parser.validateSync === 'function') {
        // ProcedureParserYupEsque
        return parser.validateSync.bind(parser);
    }
    if (typeof parser.create === 'function') {
        // ProcedureParserSuperstructEsque
        return parser.create.bind(parser);
    }
    throw new Error('Could not find a validator fn');
}
/**
 * @deprecated only for backwards compat
 * @internal
 */ function getParseFnOrPassThrough(procedureParser) {
    if (!procedureParser) {
        return (v)=>v;
    }
    return getParseFn(procedureParser);
}

/**
 * @internal
 */ const middlewareMarker = 'middlewareMarker';

function createNewBuilder(def1, def2) {
    const { middlewares =[] , inputs , ...rest } = def2;
    // TODO: maybe have a fn here to warn about calls
    return createBuilder({
        ...mergeWithoutOverrides(def1, rest),
        inputs: [
            ...def1.inputs,
            ...inputs ?? []
        ],
        middlewares: [
            ...def1.middlewares,
            ...middlewares
        ]
    });
}
function createBuilder(initDef) {
    const _def = initDef || {
        inputs: [],
        middlewares: []
    };
    return {
        _def,
        input (input) {
            const parser = getParseFn(input);
            return createNewBuilder(_def, {
                inputs: [
                    input
                ],
                middlewares: [
                    createInputMiddleware(parser)
                ]
            });
        },
        output (output) {
            const parseOutput = getParseFn(output);
            return createNewBuilder(_def, {
                output,
                middlewares: [
                    createOutputMiddleware(parseOutput)
                ]
            });
        },
        meta (meta) {
            return createNewBuilder(_def, {
                meta: meta
            });
        },
        unstable_concat (builder) {
            return createNewBuilder(_def, builder._def);
        },
        use (middleware) {
            return createNewBuilder(_def, {
                middlewares: [
                    middleware
                ]
            });
        },
        query (resolver) {
            return createResolver({
                ..._def,
                query: true
            }, resolver);
        },
        mutation (resolver) {
            return createResolver({
                ..._def,
                mutation: true
            }, resolver);
        },
        subscription (resolver) {
            return createResolver({
                ..._def,
                subscription: true
            }, resolver);
        }
    };
}
function createResolver(_def, resolver) {
    const finalBuilder = createNewBuilder(_def, {
        resolver,
        middlewares: [
            async function resolveMiddleware(opts) {
                const data = await resolver(opts);
                return {
                    marker: middlewareMarker,
                    ok: true,
                    data,
                    ctx: opts.ctx
                };
            }, 
        ]
    });
    return createProcedureCaller(finalBuilder._def);
}
const codeblock = `
If you want to call this function on the server, you do the following:
This is a client-only function.

const caller = appRouter.createCaller({
  /* ... your context */
});

const result = await caller.call('myProcedure', input);
`.trim();
function createProcedureCaller(_def) {
    const procedure = async function resolve(opts) {
        // is direct server-side call
        if (!opts || !('rawInput' in opts)) {
            throw new Error(codeblock);
        }
        // run the middlewares recursively with the resolver as the last one
        const callRecursive = async (callOpts = {
            index: 0,
            ctx: opts.ctx
        })=>{
            try {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const middleware = _def.middlewares[callOpts.index];
                const result = await middleware({
                    ctx: callOpts.ctx,
                    type: opts.type,
                    path: opts.path,
                    rawInput: opts.rawInput,
                    meta: _def.meta,
                    input: callOpts.input,
                    next: async (nextOpts)=>{
                        return await callRecursive({
                            index: callOpts.index + 1,
                            ctx: nextOpts && 'ctx' in nextOpts ? {
                                ...callOpts.ctx,
                                ...nextOpts.ctx
                            } : callOpts.ctx,
                            input: nextOpts && 'input' in nextOpts ? nextOpts.input : callOpts.input
                        });
                    }
                });
                return result;
            } catch (cause) {
                return {
                    ok: false,
                    error: getTRPCErrorFromUnknown(cause),
                    marker: middlewareMarker
                };
            }
        };
        // there's always at least one "next" since we wrap this.resolver in a middleware
        const result = await callRecursive();
        if (!result) {
            throw new TRPCError({
                code: 'INTERNAL_SERVER_ERROR',
                message: 'No result from middlewares - did you forget to `return next()`?'
            });
        }
        if (!result.ok) {
            // re-throw original error
            throw result.error;
        }
        return result.data;
    };
    procedure._def = _def;
    procedure.meta = _def.meta;
    return procedure;
}

const HTTP_METHOD_PROCEDURE_TYPE_MAP = {
    GET: 'query',
    POST: 'mutation'
};
function getRawProcedureInputOrThrow(req) {
    try {
        if (req.method === 'GET') {
            if (!req.query.has('input')) {
                return undefined;
            }
            const raw = req.query.get('input');
            return JSON.parse(raw);
        }
        if (typeof req.body === 'string') {
            // A mutation with no inputs will have req.body === ''
            return req.body.length === 0 ? undefined : JSON.parse(req.body);
        }
        return req.body;
    } catch (err) {
        throw new TRPCError({
            code: 'PARSE_ERROR',
            cause: getCauseFromUnknown(err)
        });
    }
}
async function resolveHTTPResponse(opts) {
    const { createContext , onError , router , req  } = opts;
    const batchingEnabled = opts.batching?.enabled ?? true;
    if (req.method === 'HEAD') {
        // can be used for lambda warmup
        return {
            status: 204
        };
    }
    const type = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method] ?? 'unknown';
    let ctx = undefined;
    let paths = undefined;
    const isBatchCall = !!req.query.get('batch');
    function endResponse(untransformedJSON, errors) {
        let status = getHTTPStatusCode(untransformedJSON);
        const headers = {
            'Content-Type': 'application/json'
        };
        const meta = opts.responseMeta?.({
            ctx,
            paths,
            type,
            data: Array.isArray(untransformedJSON) ? untransformedJSON : [
                untransformedJSON
            ],
            errors
        }) ?? {};
        for (const [key, value] of Object.entries(meta.headers ?? {})){
            headers[key] = value;
        }
        if (meta.status) {
            status = meta.status;
        }
        const transformedJSON = transformTRPCResponse(router, untransformedJSON);
        const body = JSON.stringify(transformedJSON);
        return {
            body,
            status,
            headers
        };
    }
    try {
        if (opts.error) {
            throw opts.error;
        }
        if (isBatchCall && !batchingEnabled) {
            throw new Error(`Batching is not enabled on the server`);
        }
        if (type === 'subscription') {
            throw new TRPCError({
                message: 'Subscriptions should use wsLink',
                code: 'METHOD_NOT_SUPPORTED'
            });
        }
        if (type === 'unknown') {
            throw new TRPCError({
                message: `Unexpected request method ${req.method}`,
                code: 'METHOD_NOT_SUPPORTED'
            });
        }
        const rawInput = getRawProcedureInputOrThrow(req);
        paths = isBatchCall ? opts.path.split(',') : [
            opts.path
        ];
        ctx = await createContext();
        const deserializeInputValue = (rawValue)=>{
            return typeof rawValue !== 'undefined' ? router._def.transformer.input.deserialize(rawValue) : rawValue;
        };
        const getInputs = ()=>{
            if (!isBatchCall) {
                return {
                    0: deserializeInputValue(rawInput)
                };
            }
            if (rawInput == null || typeof rawInput !== 'object' || Array.isArray(rawInput)) {
                throw new TRPCError({
                    code: 'BAD_REQUEST',
                    message: '"input" needs to be an object when doing a batch call'
                });
            }
            const input = {};
            for(const key in rawInput){
                const k = key;
                const rawValue = rawInput[k];
                const value = deserializeInputValue(rawValue);
                input[k] = value;
            }
            return input;
        };
        const inputs = getInputs();
        const rawResults = await Promise.all(paths.map(async (path, index)=>{
            const input = inputs[index];
            try {
                const output = await callProcedure({
                    procedures: router._def.procedures,
                    path,
                    rawInput: input,
                    ctx,
                    type
                });
                return {
                    input,
                    path,
                    data: output
                };
            } catch (cause) {
                const error = getTRPCErrorFromUnknown(cause);
                onError?.({
                    error,
                    path,
                    input,
                    ctx,
                    type: type,
                    req
                });
                return {
                    input,
                    path,
                    error
                };
            }
        }));
        const errors = rawResults.flatMap((obj)=>obj.error ? [
                obj.error
            ] : []);
        const resultEnvelopes = rawResults.map((obj)=>{
            const { path , input  } = obj;
            if (obj.error) {
                return {
                    error: router.getErrorShape({
                        error: obj.error,
                        type,
                        path,
                        input,
                        ctx
                    })
                };
            } else {
                return {
                    result: {
                        data: obj.data
                    }
                };
            }
        });
        const result = isBatchCall ? resultEnvelopes : resultEnvelopes[0];
        return endResponse(result, errors);
    } catch (cause) {
        // we get here if
        // - batching is called when it's not enabled
        // - `createContext()` throws
        // - post body is too large
        // - input deserialization fails
        const error = getTRPCErrorFromUnknown(cause);
        onError?.({
            error,
            path: undefined,
            input: undefined,
            ctx,
            type: type,
            req
        });
        return endResponse({
            error: router.getErrorShape({
                error,
                type,
                path: undefined,
                input: undefined,
                ctx
            })
        }, [
            error
        ]);
    }
}

export { defaultTransformer as a, createBuilder as b, createRouterFactory as c, defaultFormatter as d, createMiddlewareFactory as e, assertNotBrowser as f, getDataTransformer as g, callProcedure as h, createInputMiddleware as i, createOutputMiddleware as j, getParseFnOrPassThrough as k, getHTTPStatusCodeFromError as l, mergeWithoutOverrides as m, procedureTypes as p, resolveHTTPResponse as r };
