import { f as assertNotBrowser, m as mergeWithoutOverrides, c as createRouterFactory, k as getParseFnOrPassThrough, i as createInputMiddleware, b as createBuilder, j as createOutputMiddleware, d as defaultFormatter, l as getHTTPStatusCodeFromError, a as defaultTransformer } from './resolveHTTPResponse-fa4e77dd.mjs';
import { T as TRPC_ERROR_CODES_BY_KEY } from './codes-f164ac85.mjs';
import { T as TRPCError, g as getCauseFromUnknown, a as getTRPCErrorFromUnknown } from './TRPCError-e99e7cbe.mjs';

assertNotBrowser();

/**
 * @deprecated
 */ const middlewareMarker = 'middlewareMarker';

assertNotBrowser();
function getParseFn(procedureParser) {
    const parser = procedureParser;
    if (typeof parser === 'function') {
        // ProcedureParserCustomValidatorEsque
        return parser;
    }
    if (typeof parser.parseAsync === 'function') {
        // ProcedureParserZodEsque
        return parser.parseAsync.bind(parser);
    }
    if (typeof parser.parse === 'function') {
        // ProcedureParserZodEsque
        return parser.parse.bind(parser);
    }
    if (typeof parser.validateSync === 'function') {
        // ProcedureParserYupEsque
        return parser.validateSync.bind(parser);
    }
    if (typeof parser.create === 'function') {
        // ProcedureParserSuperstructEsque
        return parser.create.bind(parser);
    }
    throw new Error('Could not find a validator fn');
}
/**
 * @internal
 * @deprecated
 */ class Procedure {
    _def() {
        return {
            middlewares: this.middlewares,
            resolver: this.resolver,
            inputParser: this.inputParser,
            outputParser: this.outputParser,
            meta: this.meta
        };
    }
    async parseInput(rawInput) {
        try {
            return await this.parseInputFn(rawInput);
        } catch (cause) {
            throw new TRPCError({
                code: 'BAD_REQUEST',
                cause: getCauseFromUnknown(cause)
            });
        }
    }
    async parseOutput(rawOutput) {
        try {
            return await this.parseOutputFn(rawOutput);
        } catch (cause) {
            throw new TRPCError({
                code: 'INTERNAL_SERVER_ERROR',
                cause: getCauseFromUnknown(cause),
                message: 'Output validation failed'
            });
        }
    }
    /**
   * Trigger middlewares in order, parse raw input, call resolver & parse raw output
   * @internal
   */ async call(opts) {
        // wrap the actual resolver and treat as the last "middleware"
        const middlewaresWithResolver = this.middlewares.concat([
            async ({ ctx  })=>{
                const input = await this.parseInput(opts.rawInput);
                const rawOutput = await this.resolver({
                    ...opts,
                    ctx,
                    input
                });
                const data = await this.parseOutput(rawOutput);
                return {
                    marker: middlewareMarker,
                    ok: true,
                    data,
                    ctx
                };
            }, 
        ]);
        // run the middlewares recursively with the resolver as the last one
        const callRecursive = async (callOpts = {
            index: 0,
            ctx: opts.ctx
        })=>{
            try {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const result = await middlewaresWithResolver[callOpts.index]({
                    ctx: callOpts.ctx,
                    type: opts.type,
                    path: opts.path,
                    rawInput: opts.rawInput,
                    meta: this.meta,
                    next: async (nextOpts)=>{
                        return await callRecursive({
                            index: callOpts.index + 1,
                            ctx: nextOpts ? nextOpts.ctx : callOpts.ctx
                        });
                    }
                });
                return result;
            } catch (cause) {
                return {
                    ctx: callOpts.ctx,
                    ok: false,
                    error: getTRPCErrorFromUnknown(cause),
                    marker: middlewareMarker
                };
            }
        };
        // there's always at least one "next" since we wrap this.resolver in a middleware
        const result = await callRecursive();
        if (!result) {
            throw new TRPCError({
                code: 'INTERNAL_SERVER_ERROR',
                message: 'No result from middlewares - did you forget to `return next()`?'
            });
        }
        if (!result.ok) {
            // re-throw original error
            throw result.error;
        }
        return result.data;
    }
    /**
   * Create new procedure with passed middlewares
   * @param middlewares
   */ inheritMiddlewares(middlewares) {
        const Constructor = this.constructor;
        const instance = new Constructor({
            middlewares: [
                ...middlewares,
                ...this.middlewares
            ],
            resolver: this.resolver,
            inputParser: this.inputParser,
            outputParser: this.outputParser,
            meta: this.meta
        });
        return instance;
    }
    constructor(opts){
        this.middlewares = opts.middlewares;
        this.resolver = opts.resolver;
        this.inputParser = opts.inputParser;
        this.parseInputFn = getParseFn(this.inputParser);
        this.outputParser = opts.outputParser;
        this.parseOutputFn = getParseFn(this.outputParser);
        this.meta = opts.meta;
    }
}
function createProcedure(opts) {
    const inputParser = 'input' in opts ? opts.input : (input)=>{
        if (input != null) {
            throw new TRPCError({
                code: 'BAD_REQUEST',
                message: 'No input expected'
            });
        }
        return undefined;
    };
    const outputParser = 'output' in opts && opts.output ? opts.output : (output)=>output;
    return new Procedure({
        inputParser: inputParser,
        resolver: opts.resolve,
        middlewares: [],
        outputParser: outputParser,
        meta: opts.meta
    });
}

function migrateProcedure(oldProc, type) {
    const def = oldProc._def();
    const inputParser = getParseFnOrPassThrough(def.inputParser);
    const outputParser = getParseFnOrPassThrough(def.outputParser);
    const inputMiddleware = createInputMiddleware(inputParser);
    const builder = createBuilder({
        inputs: [
            def.inputParser
        ],
        middlewares: [
            ...def.middlewares,
            inputMiddleware,
            createOutputMiddleware(outputParser), 
        ],
        meta: def.meta,
        output: def.outputParser,
        mutation: type === 'mutation',
        query: type === 'query',
        subscription: type === 'subscription'
    });
    const proc = builder[type]((opts)=>def.resolver(opts));
    return proc;
}
function migrateRouter(oldRouter) {
    const errorFormatter = oldRouter._def.errorFormatter;
    const transformer = oldRouter._def.transformer;
    const queries = {};
    const mutations = {};
    const subscriptions = {};
    for (const [name, procedure] of Object.entries(oldRouter._def.queries)){
        queries[name] = migrateProcedure(procedure, 'query');
    }
    for (const [name1, procedure1] of Object.entries(oldRouter._def.mutations)){
        mutations[name1] = migrateProcedure(procedure1, 'mutation');
    }
    for (const [name2, procedure2] of Object.entries(oldRouter._def.subscriptions)){
        subscriptions[name2] = migrateProcedure(procedure2, 'subscription');
    }
    const procedures = mergeWithoutOverrides(queries, mutations, subscriptions);
    const newRouter = createRouterFactory({
        transformer,
        errorFormatter
    })(procedures);
    return newRouter;
}

assertNotBrowser();
function getDataTransformer(transformer) {
    if ('input' in transformer) {
        return transformer;
    }
    return {
        input: transformer,
        output: transformer
    };
}
const PROCEDURE_DEFINITION_MAP = {
    query: 'queries',
    mutation: 'mutations',
    subscription: 'subscriptions'
};
function safeObject(...args) {
    return Object.assign(Object.create(null), ...args);
}
/**
 * @internal The type signature of this class may change without warning.
 * @deprecated
 */ class Router {
    static prefixProcedures(procedures, prefix) {
        const eps = safeObject();
        for (const [key, procedure] of Object.entries(procedures)){
            eps[prefix + key] = procedure;
        }
        return eps;
    }
    query(path, procedure) {
        const router = new Router({
            queries: safeObject({
                [path]: createProcedure(procedure)
            })
        });
        return this.merge(router);
    }
    mutation(path, procedure) {
        const router = new Router({
            mutations: safeObject({
                [path]: createProcedure(procedure)
            })
        });
        return this.merge(router);
    }
    subscription(path, procedure) {
        const router = new Router({
            subscriptions: safeObject({
                [path]: createProcedure(procedure)
            })
        });
        return this.merge(router);
    }
    merge(prefixOrRouter, maybeRouter) {
        let prefix = '';
        let childRouter;
        if (typeof prefixOrRouter === 'string' && maybeRouter instanceof Router) {
            prefix = prefixOrRouter;
            childRouter = maybeRouter;
        } else if (prefixOrRouter instanceof Router) {
            childRouter = prefixOrRouter;
        } else {
            throw new Error('Invalid args');
        }
        const duplicateQueries = Object.keys(childRouter._def.queries).filter((key)=>!!this._def['queries'][prefix + key]);
        const duplicateMutations = Object.keys(childRouter._def.mutations).filter((key)=>!!this._def['mutations'][prefix + key]);
        const duplicateSubscriptions = Object.keys(childRouter._def.subscriptions).filter((key)=>!!this._def['subscriptions'][prefix + key]);
        const duplicates = [
            ...duplicateQueries,
            ...duplicateMutations,
            ...duplicateSubscriptions, 
        ];
        if (duplicates.length) {
            throw new Error(`Duplicate endpoint(s): ${duplicates.join(', ')}`);
        }
        const mergeProcedures = (defs)=>{
            const newDefs = safeObject();
            for (const [key, procedure] of Object.entries(defs)){
                const newProcedure = procedure.inheritMiddlewares(this._def.middlewares);
                newDefs[key] = newProcedure;
            }
            return Router.prefixProcedures(newDefs, prefix);
        };
        return new Router({
            ...this._def,
            queries: safeObject(this._def.queries, mergeProcedures(childRouter._def.queries)),
            mutations: safeObject(this._def.mutations, mergeProcedures(childRouter._def.mutations)),
            subscriptions: safeObject(this._def.subscriptions, mergeProcedures(childRouter._def.subscriptions))
        });
    }
    /**
   * Invoke procedure. Only for internal use within library.
   */ async call(opts) {
        const { type , path  } = opts;
        const defTarget = PROCEDURE_DEFINITION_MAP[type];
        const defs = this._def[defTarget];
        const procedure = defs[path];
        if (!procedure) {
            throw new TRPCError({
                code: 'NOT_FOUND',
                message: `No "${type}"-procedure on path "${path}"`
            });
        }
        return procedure.call(opts);
    }
    createCaller(ctx) {
        return {
            query: (path, ...args)=>{
                return this.call({
                    type: 'query',
                    ctx,
                    path,
                    rawInput: args[0]
                });
            },
            mutation: (path, ...args)=>{
                return this.call({
                    type: 'mutation',
                    ctx,
                    path,
                    rawInput: args[0]
                });
            },
            subscription: (path, ...args)=>{
                return this.call({
                    type: 'subscription',
                    ctx,
                    path,
                    rawInput: args[0]
                });
            }
        };
    }
    /**
   * Function to be called before any procedure is invoked
   * @link https://trpc.io/docs/middlewares
   */ middleware(middleware) {
        return new Router({
            ...this._def,
            middlewares: [
                ...this._def.middlewares,
                middleware
            ]
        });
    }
    /**
   * Format errors
   * @link https://trpc.io/docs/error-formatting
   */ formatError(errorFormatter) {
        if (this._def.errorFormatter !== defaultFormatter) {
            throw new Error('You seem to have double `formatError()`-calls in your router tree');
        }
        return new Router({
            ...this._def,
            errorFormatter: errorFormatter
        });
    }
    getErrorShape(opts) {
        const { path , error  } = opts;
        const { code  } = opts.error;
        const shape = {
            message: error.message,
            code: TRPC_ERROR_CODES_BY_KEY[code],
            data: {
                code,
                httpStatus: getHTTPStatusCodeFromError(error)
            }
        };
        if (process.env.NODE_ENV !== 'production' && typeof opts.error.stack === 'string') {
            shape.data.stack = opts.error.stack;
        }
        if (typeof path === 'string') {
            shape.data.path = path;
        }
        return this._def.errorFormatter({
            ...opts,
            shape
        });
    }
    /**
   * Add data transformer to serialize/deserialize input args + output
   * @link https://trpc.io/docs/data-transformers
   */ transformer(_transformer) {
        const transformer = getDataTransformer(_transformer);
        if (this._def.transformer !== defaultTransformer) {
            throw new Error('You seem to have double `transformer()`-calls in your router tree');
        }
        return new Router({
            ...this._def,
            transformer
        });
    }
    /**
   * Flattens the generics of TQueries/TMutations/TSubscriptions.
   * ⚠️ Experimental - might disappear. ⚠️
   *
   * @alpha
   */ flat() {
        return this;
    }
    /**
   * Interop mode for v9.x -> v10.x
   */ interop() {
        return migrateRouter(this);
    }
    constructor(def){
        this._def = {
            queries: def?.queries ?? safeObject(),
            mutations: def?.mutations ?? safeObject(),
            subscriptions: def?.subscriptions ?? safeObject(),
            middlewares: def?.middlewares ?? [],
            errorFormatter: def?.errorFormatter ?? defaultFormatter,
            transformer: def?.transformer ?? defaultTransformer
        };
    }
}
/**
 * @deprecated
 */ function router() {
    return new Router();
}

export { router as r };
